#! /usr/bin/env python

import sys, os, string
import time, datetime
import random


#
# Simple script to make IPSec tunnel configurations for use with
# Linux/BSD 'setkey' utility
#
# Author: Sudhi Herle <sudhi@herle.net>
# License: GPLv2
#


# Customizations go here.

# Subnets in India
remote_nets = [ "192.168.1.0/24", "192.168.2.0/24", ]

# Subnets in US
local_nets    = [ "172.16.1.0/24",  "172.16.2.0/24", ]

# Public IP addresses - remote & local
remote_pub    = "55.66.77.88"
local_pub     = "100.100.100.100"

#
# DO NOT MODIFY ANYTHING BELOW THIS
#

def randpass(len):
    """Make a random password and return as string"""

    r   = random.Random()
    str = ""
    n   = len
    while n > 0:
        n -= 1
        str += "%02x" % r.randint(0, 255)

    return str


# Security identifiers for each part of the tunnel
r = random.Random()
remote_local_spi = "%#0#x" % r.randint(0, 0xffffffff)
local_remote_spi = "%#08x" % r.randint(0, 0xffffffff)

sel_template = """spdadd %(there)s  %(here)s any -P %(direction)s ipsec
    esp/tunnel/%(remote)s-%(local)s/require;
"""


prologue = """#! /usr/sbin/setkey -f

#
# IPSec static tunnel configuration
# Autogenerated by %(prog)s
# Date: %(date)s
#
# Local  = %(local)s
# Remote = %(remote)s

flush;
spdflush;

add %(remotepub)s %(uspub)s esp %(remote_local_spi)s
    -m tunnel
    -E aes-cbc 0x%(aespass)s
    -A hmac-sha1 0x%(hmacpass)s;

add %(uspub)s %(remotepub)s esp %(local_remote_spi)s
    -m tunnel
    -E aes-cbc 0x%(aespass)s
    -A hmac-sha1 0x%(hmacpass)s;

"""

prologue_remote = """
add %(remotepub)s %(uspub)s esp %(remote_local_spi)s
    -m tunnel
    -E aes-cbc 0x%(aespass)s
    -A hmac-sha1 0x%(hmacpass)s;

add %(uspub)s %(remotepub)s %esp %(local_remote_spi)s
    -m tunnel
    -E aes-cbc 0x%(aespass)s
    -A hmac-sha1 0x%(hmacpass)s;
"""


epilogue = """# End of rules


dump;
spddump;

# EOF
"""



def add_rule(local, remote, here_nets, there_nets, direction):
    d = {
        'local':    local,
        'remote':   remote,
        'direction':direction,
    }

    rules = "# Rules for packets %s\n\n" % direction
    for here in here_nets:
        for there in there_nets:
            d['here']  = here
            d['there'] = there
            rules += sel_template % d
            rules += "\n"

    return rules


def writefile(fn, str):
    fd = open(fn, "w")
    fd.write(str)
    fd.close()

def local_to_remote(d, outfile):
    in_rules  = add_rule(local_pub, remote_pub, local_nets, remote_nets, 'in')
    out_rules = add_rule(remote_pub, local_pub, remote_nets, local_nets, 'out')

    d['local']  = local_pub
    d['remote'] = remote_pub
    rules  = prologue % d
    rules += """

%s


%s

%s""" % (in_rules, out_rules, epilogue)

    writefile(outfile, rules)

def remote_to_local(d, outfile):
    in_rules  = add_rule(local_pub, remote_pub, local_nets, remote_nets, 'out')
    out_rules = add_rule(remote_pub, local_pub, remote_nets, local_nets, 'in')

    d['local']  = remote_pub
    d['remote'] = local_pub
    rules  = prologue % d
    rules += """

%s


%s

%s""" % (in_rules, out_rules, epilogue)

    writefile(outfile, rules)


if len(sys.argv) < 3:
    print >>sys.stderr, "Usage: %s remote.conf us.conf" % sys.argv[0]
    sys.exit(1)

now  = datetime.datetime.now()
d = { 'prog': sys.argv[0],
      'date': "%s" % now,
      'aespass':  randpass(16),
      'hmacpass': randpass(20),
      'remotepub': remote_pub,
      'uspub': local_pub,
      'remote_local_spi': remote_local_spi,
      'local_remote_spi': local_remote_spi,
    }

# Generate remote and us config in one shot
remote_to_local(d, sys.argv[1])
local_to_remote(d, sys.argv[2])

# EOF
